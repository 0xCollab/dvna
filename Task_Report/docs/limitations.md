# Limitations

## Objective

The aim of this section is to create a similar pipeline for SuiteCRM, a different application than DVNA, to identify assumptions made whilst creating the pipeline for DVNA to provide a solution for 1st point of the [problem statement](/problem_statement) under `Task 5`.

## SuiteCRM

The application that I chose for the validation of the previously built pipeline was [SuiteCRM](https://suitecrm.com/). It is a Customer Relationship Management tool which is the open-source forked version of [SugarCRM](https://www.sugarcrm.com/). SuiteCRM adds a few additional features to its fork and is free to use.

I chose the application because of of it being a bigger application than DVNA and it is also an application that is used in the real-world and is not just a dummy application. Another reason was that it is written in PHP and hence, the difference in stack from DVNA also would help identifying assumptions made in the previous pipeline created as the solution to the problem statements.

### Configuration

Before I began setting up tools on the virtual machine, I forked the SuiteCRM GitHub repository on my own account. My fork of SuiteCRM can be found [here](https://github.com/ayushpriya10/SuiteCRM).

I also created a new pipeline, named `suitecrm-aws-pipeline`, following the steps from this report's earlier section on [Setting Up Pipeline](/setting_up_pipeline/#jenkins-pipeline-project).

Since SuiteCRM is written in PHP, I had to install a few things on the Jenkins EC2 instance. I followed this [article](https://dzone.com/articles/step-by-step-guide-to-setting-up-a-local-suitecrm) to perform the necessary configurations for the application. I did, however, skipped all steps related to installing and configuring `MariaDB` as I already had `MySQL Community` installed on the system. I also skipped the 10th step as I cloned my fork of the SuiteCRM GitHub repository and did not use the zipped archive to get the source code of the applications. Lastly, I also skipped steps 19 and 20 because I did not need to set up the `Cron` job as it was not required in the context of the problem statement.

* Trying to view SuiteCRM from the browser (step 12 from the article) I faced an issue that the packages were not built. This was due to me cloning the repository instead of using the zip archive. Hence, I had to install `Composer`, the package manager for PHP. I followed the [official documentation](https://getcomposer.org/doc/00-intro.md) and performed to required steps to install `Composer` globally. After a successful installation, I ran `composer install` in the project's root directory to build the dependencies for SuiteCRM.

* Since SuiteCRM is a PHP application, I also needed to install a web-server to serve the application. I chose `Apache` for this as mentioned in the article I was using to set up SuiteCRM. Since, I had previously mapped port 80 to Jenkins' port 8080, I had to change the port Apache would listen on. To do this, I used the command - `sudo nano /etc/apache2/ports.conf` and made the following changes to make Apache listen on port 9090:

```apache2-conf
#Listen 80
Listen 9090

<IfModule ssl_module>
    Listen 443
</IfModule>

<IfModule mod_gnutls.c>
    Listen 443
</IfModule>
```

## SAST

The first thing that came to light while creating the pipeline for SuiteCRM was the fact that since it was based on a different tech stack than DVNA, most of the SAST tools I used previously were incompatible with it. The only two tools that worked with both DVNA and SuiteCRM are mentioned below:

### **Dependency Check**  

Since it was already installed I did not need do a fresh installation for Dependency Check. I amended the command to point to the workspace directory of the new pipeline (`/{JENKINS HOME DIRECTORY}/workspace/suitecrm-aws-pipeline`). I also renamed the output to be called `suitecrm-dependency-check-report`.

The complete report generated by Dependency Check for SuiteCRM can be [here]().

### **Snyk**  

Like Dependency Checkm, since Snyk was already installed I just created a new script to run Synk from. I amended the script, like Dependency Check,to point to `/{JENKINS HOME DIRECTORY}/workspace/suitecrm-aws-pipeline` and renamed the output report as `suitecrm-snyk-report`. The rest of the script remained as it is.

The complete report generated by Snyk for SuiteCRM can be [here]().

Since majority of the previously used SAST tools were not suitable to test a PHP application, I found two new tools built to perform SAST specifically on PHP applications. These applications are mentioned below:

### **Symfony**  

I followed the [official documentation](https://github.com/sensiolabs/security-checker) to download the `Symfony CLI` executable from this [link](https://symfony.com/download) mentioned in the documentation and moved it to `/usr/local/bin` to be accessible for all users. I used the binary executable as it was more convenient than using `Composer` to install it as a package. Symfony gave a non-zero status code on identifying issues so I wrote a bash script (`suitecrm-symfony.sh`) and placed it under `tool_scripts/` directory.

The complete report generated by Symfony for SuiteCRM can be [here]().

The contents of the script (`suitecrm-symfony.sh`) are mentioned below:

```bash
#!/bin/bash

symfony security:check --dir /{JENKINS HOME DIRECTORY}/workspace/suitecrm-aws-pipeline --format json > /{JENKINS HOME DIRECTORY}/reports/suitecrm-symfony-report

echo $?> /dev/null
```

### **PHP Malware Finder**  

I followed the [documentation](https://github.com/jvoisin/php-malware-finder) present in the official GitHub repository for PHP Malware Finder (PMF). I first installed `Yara` with `apt` and then cloned the repository as instructed in the documentation in the `tool_scripts` directory. Since PMF did not exited with a non-zero code even after identifying a security issue, I added the scan command `/{JENKINS HOME DIRECTORY}/tool_scripts/php-malware-finder/php-malware-finder/phpmalwarefinder $(pwd) > /{JENKINS HOME DIRECTORY}/reports/suitecrm-pmf-report` as it is to a stage in the pipeline.

The complete report generated by PHP Malware Finder for SuiteCRM can be [here]().

## DAST

To perform DAST, I had to deploy SuiteCRM on the Jenkins EC2 instance for the tools to perform scans and attack the application. Another limitation that became evident was the fact that removing all application files and _cloning_ a new copy from the source code repository required me to do the configuration for the application through the web-based console even if the database had the relevant entries persisted on the database. I looked around in the changes that happened after doing the initial configuration with the web-based console and found that SuiteCRM creates a new file, `config.php`, which stored the settings. The solution to this was to retain this configuration file while being able to fetch changes made to the source-code of the application. I thought of two solutions - store this config file locally and copy it after a fresh fetch of the source code or, the simpler solution, pull changes from the repository with a `git pull`. I chose the latter as it was the simpler solution.

The next limitation surfaced when I had to use Apache as the web-server as SuiteCRM, unlike DVNA, does not ship with a development server. The problem was that starting and stopping Apache's service on the virtual machine required `sudo` privileges, that were not granted to the Jenkins system user. I found this [answer](https://serverfault.com/questions/69847/linux-how-to-give-a-user-permission-to-restart-apache) on StackOverflow which explained how to grant _passwordless_ `sudo` privileges for specific executables/scripts. I used this answer as reference to add the Jenkins system user to the `sudoers` file and grant it `sudo` privilege to start and stop the Apache web-server. I amended the `sudoers` file by adding the following line to it under `User privilege specification`:

```sudoers
jenkins ALL= NOPASSWD: /etc/init.d/apache2
```

After granting the required privilege to Jenkins system user, I used the following commands to start and stop the Apache web-server:

```bash
# To start the web-server
sudo /etc/init.d/apache2 start

# To stop the web-server
sudo /etc/init.d/apache2 stop
```

Since DAST is a black-box testing, where the tool interacts with the application being tested by performing actions like an attacker would, both the previously used tools (OWASP ZAP and W3AF) worked with SuiteCRM without any issues. I used the Jenkins Agent EC2 instance to run the tests like I did previously. The changes I made are mentioned below:

### **OWASP ZAP**  

I wrote an identical script as before and changed the output report's name to `suitecrm-zap-report`. I added a stage in the pipeline to use this new script to perform DAST on SuiteCRM.

The complete report generated by OWASP ZAP for SuiteCRM can be [here]().

### **W3AF**  

I wrote an identical configuration script for W3AF as before and changed the values to reflect the names of 'username' and 'password' fields on the login page for SuiteCRM. I also renamed the output report's name to `suitecrm-w3af-report`. I added a stage in the pipeline to run the W3AF console executable with the new configuration script.

The complete report generated by W3AF for SuiteCRM can be [here]().

## Code Quality Analysis

Since the tools used for Code Quality Analysis are language-specific, I could not use the tools I used before for DVNA. Hence, I found a couple of tools that are meant for PHP applications. The tools I used are PHP Code Sniffer (PHPCS) and PHP Mess Detector (PHPMD).

### PHP Code Sniffer

[PHP Code Sniffer](https://github.com/squizlabs/PHP_CodeSniffer) or PHPCS is a set of two PHP scripts - one that analyzes the code for violations of coding conventions and the other which can automatically fix the identified issues. For the purpose of the task in the problem statement, I was only concerned with identifying the linting issues and hence skipped the second script.

* To install PHPCS for Code Quality Analysis, I downloaded the `phar` executable for the scanner with `wget` (as instructed in the [documentation](https://github.com/squizlabs/PHP_CodeSniffer)), made it executable with `chmod` and moved it to `/usr/local/bin/` for it to be accessible to all system users. The commands I used to achieve these steps are mentioned below:

```bash
wget https://squizlabs.github.io/PHP_CodeSniffer/phpcs.phar
chmod +x phpcs.phar
mv phpcs.phar /usr/local/bin/phpcs
```

* Next, I ran it PHPCS on the SuiteCRM project directory with the command mentioned below:

```bash
phpcs /{JENKINS HOME DIRECTORY}/workspace/suitecrm-aws-pipeline
```

**Note**: Executing PHPCS on the whole project directory caused the virtual machine to run out of free memory which crashed PHPCS. So, I wrote a Python script to identify all PHP files present in the SuiteCRM project directory and ran PHPCS on the files individually and appended these individual results to `suitecrm-phpcs-report`. The contents of the script I wrote are mentioned below:

```python
#!/usr/bin/python3

import os
import sys

try:
    BASE_PATH = sys.argv[1]

except IndexError:
    print('[-] Path not supplied...')
    sys.exit(1)

paths = [BASE_PATH]
php_files = []

print('[+] Scanning directory for PHP files...')
while paths != []:
    base_path = paths.pop()

    try:
        with os.scandir(base_path) as entries:
            for entry in entries:
                if entry.is_file():
                    if entry.name.endswith('.php'):
                        php_files.append(os.path.join(base_path, entry.name))
                else:
                    paths.append(os.path.join(base_path, entry.name))

    except PermissionError:
        print(f'[-] Could not open {base_path} due to insufficient permission...')

print('[+] Scan completed...')

print('[+] Running linter on PHP files...')
try:
    for php_file in php_files:
        print(f'[+] Scanning {php_file}')
        os.system(f'phpcs {php_file} >> /var/lib/jenkins/reports/suitecrm-phpcs-report')
    print('[+] All PHP files scanned...')
    print('[+] Code Quality Report generated...')

except KeyboardInterrupt:
    print('[-] Exiting...')
```

* Lastly, I added the a stage in the pipeline to execute the Python script by supplying it the path of the project directory to scan.

The code analysis report generated by PHP Code Sniffer can be found [here]().

### PHP Mess Detector

PHP Mess Detector is another tool that finds Linting issues in PHP code. It is quite similar to PHPCS in terms of installation but has more customisability by allowing the user to write custom rules for the analysis as well as writing the output to a file in XML, HTML, Text and JSON formats.

* To start off, I downloaded the `phar` executable with the below mentioned command, as instructed in the [official documentation](https://phpmd.org/download/index.html):

```bash
wget https://phpmd.org/static/latest/phpmd.phar
```

* Next, I made it executable with `chmod` and then moved the executable to `/usr/local/bin` to make it accessible to all system users:

```bash
chmod +x phpmd.phar
mv phpmd.phar /usr/local/bin/phpmd
```

* Then I tested the tool by executing it against the project directory for SuiteCRM with the below mentioned command, where the output report would be in XML format and the rule-set used would be `cleancode` that comes along with PHPMD:

```bash
phpmd /path/to/source/ xml cleancode --reportfile /{JENKINS HOME DIRECTORY}/reports/suitecrm-phpmd-report
```

* Lastly, I added a stage to the pipeline to run the required command, generate the report and store it in the `reports/` directory.

The code analysis report generated by PHP Mess Detector can be found [here]().

## Generating Software Bill of Materials

Unlike DVNA, which is built on Nodejs, SuiteCRM is a PHP application and hence, I could not have used the CycloneDX's Nodejs binding. So, I had to switch to the PHP binding available from CycloneDX which can be found [here](https://github.com/CycloneDX/cyclonedx-php-composer).

* I had to first install `cyclonedx-php-composer` for which I used the command mentioned in the documentation present in the GitHub repository:

```bash
composer require --dev cyclonedx/cyclone-php-composer
```

* Then to verify it was working, I ran the following command to generate the SBoM:

```bash
composer make-bom
```

* After verifying the SBoM generated, I added a stage in the pipeline to install `cyclonedx-php-composer` as a `dev` dependency, run it to generate the SBoM and lastly, move the SBoM to the `reports/` directory.

The Software Bill of Materials generated by CycloneDX can be found [here]().

## Deploying SuiteCRM

SuiteCRM posed another challenge when it came to deploying it to production. Since, it created a dynamic configuration file (`config.php`) after the initial installation and using the Docker image would require to go through the set up after each deployment, I chose to use a EC2 instance to deploy SuiteCRM. Also, now that I was using a full-fledged virtual machine, I set up the database for SuiteCRM also on the instance itself. The following are the steps I added to the stage to deploy SuiteCRM to the production EC2 instance:

* First, I copied the dependencies built locally in the Jenkins EC2 instance over to the production instance in a directory `suitecrm/`.

```bash
scp -r * ubuntu@<PRODUCTION VM IP>:/home/ubuntu/suitecrm
```

* Next, I stopped the Apache service running on the production instance.

```bash
ssh -o StrictHostKeyChecking=no ubuntu@<PRODUCTION VM IP> "sudo systemctl stop apache2"
```

* I removed the existing files from `/var/www/html/` for SuiteCRM's previous deployment.

```bash
ssh -o StrictHostKeyChecking=no ubuntu@<PRODUCTION VM IP> "sudo rm -r /var/www/html/*"
```

* I copied over the new files from `suitecrm/` to `/var/www/html`.

```bash
ssh -o StrictHostKeyChecking=no ubuntu@<PRODUCTION VM IP> "sudo cp -r suitecrm/* /var/www/html"
```

* I also copied the `config.php` file that contained all the configuration created from the first deployment of SuiteCRM on the production instance.

```bash
ssh -o StrictHostKeyChecking=no ubuntu@<PRODUCTION VM IP> "sudo cp config.php /var/www/html"
```

* I changed the owner of the copied files to `www-data` with `sudo chown -R www-data: /var/www/html`.

```bash
ssh -o StrictHostKeyChecking=no ubuntu@<PRODUCTION VM IP> "sudo chown -R www-data: /var/www/html"
```

* Next, I restarted the Apache web-server.

```bash
ssh -o StrictHostKeyChecking=no ubuntu@<PRODUCTION VM IP> "sudo systemctl start apache2"
```

* Lastly, I created a stage in the pipeline to add all the above mentioned steps for deployment.
